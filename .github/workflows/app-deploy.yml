name: "DefectDojo Application Build & Deploy"

on:
  workflow_dispatch:
    inputs:
      force_deploy:
        description: "Force ECS service deployment"
        required: false
        default: true
        type: boolean

  push:
    branches: [main]
    paths:
      - "app/**"

permissions:
  id-token: write # Required for AWS OIDC
  contents: read # Required for checkout

env:
  AWS_REGION: "us-east-1"
  PROJECT_NAME: "defectdojo-mvp"

jobs:
  build-and-deploy:
    name: "Build and Deploy DefectDojo"
    runs-on: ubuntu-latest

    steps:
      - name: "Checkout Repository"
        uses: actions/checkout@v4

      - name: "Configure AWS Credentials"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GithubInfraRole-AppDeploy
          aws-region: ${{ env.AWS_REGION }}

      - name: "Get ECR Registry and Repositories"
        id: ecr_info
        run: |
          # Get AWS Account ID
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"

          # Use commit SHA for production builds, or 'dev' for feature branches
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            IMAGE_TAG="${{ github.sha }}"
          else
            IMAGE_TAG="dev-$(echo ${{ github.sha }} | cut -c1-8)"
          fi

          # Set environment variables for use in subsequent steps
          echo "ECR_REGISTRY=${ECR_REGISTRY}" >> $GITHUB_ENV
          echo "DJANGO_REPO=${ECR_REGISTRY}/${{ env.PROJECT_NAME }}/django" >> $GITHUB_ENV
          echo "NGINX_REPO=${ECR_REGISTRY}/${{ env.PROJECT_NAME }}/nginx" >> $GITHUB_ENV
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV

          echo "ðŸ“‹ Build Configuration:"
          echo "Registry: ${ECR_REGISTRY}"
          echo "Image Tag: ${IMAGE_TAG}"

      - name: "Login to Amazon ECR"
        uses: aws-actions/amazon-ecr-login@v2

      - name: "Set up Docker Buildx"
        uses: docker/setup-buildx-action@v3

      - name: "Build and push Django image"
        working-directory: ./app
        run: |
          echo "ðŸ”¨ Building Django image: $DJANGO_REPO"

          docker build \
            -f Dockerfile.django-alpine \
            --target django \
            --platform linux/amd64 \
            -t $DJANGO_REPO:$IMAGE_TAG \
            -t $DJANGO_REPO:latest \
            .

          echo "ðŸ“¤ Pushing Django image..."
          docker push $DJANGO_REPO:$IMAGE_TAG
          docker push $DJANGO_REPO:latest

          echo "âœ… Django image: $DJANGO_REPO:$IMAGE_TAG"

      - name: "Build and push Nginx image"
        working-directory: ./app
        run: |
          echo "ðŸ”¨ Building Nginx image: $NGINX_REPO"

          docker build \
            -f Dockerfile.nginx-alpine \
            --platform linux/amd64 \
            -t $NGINX_REPO:$IMAGE_TAG \
            -t $NGINX_REPO:latest \
            .

          echo "ðŸ“¤ Pushing Nginx image..."
          docker push $NGINX_REPO:$IMAGE_TAG
          docker push $NGINX_REPO:latest

          echo "âœ… Nginx image: $NGINX_REPO:$IMAGE_TAG"

      - name: "Deploy to ECS"
        if: inputs.force_deploy == true || github.event_name == 'push'
        run: |
          echo "ðŸš€ Deploying to ECS..."

          # Get current task definition
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition ${{ env.PROJECT_NAME }}-defectdojo \
            --query 'taskDefinition')

          # Update task definition with new image URIs
          NEW_TASK_DEF=$(echo $TASK_DEF | jq --arg DJANGO_IMAGE "$DJANGO_REPO:$IMAGE_TAG" \
                                              --arg NGINX_IMAGE "$NGINX_REPO:$IMAGE_TAG" \
            '
            .containerDefinitions |= map(
              if .name == "django" then .image = $DJANGO_IMAGE
              elif .name == "nginx" then .image = $NGINX_IMAGE
              else . end
            ) |
            del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)
            ')

          # Register new task definition
          echo "ðŸ“ Registering new task definition..."
          NEW_TASK_DEF_ARN=$(echo $NEW_TASK_DEF | aws ecs register-task-definition --cli-input-json file:///dev/stdin --query 'taskDefinition.taskDefinitionArn' --output text)

          # Update service with new task definition
          echo "ðŸ”„ Updating ECS service..."
          aws ecs update-service \
            --cluster ${{ env.PROJECT_NAME }}-cluster \
            --service ${{ env.PROJECT_NAME }}-service \
            --task-definition $NEW_TASK_DEF_ARN \
            --force-new-deployment
            
          echo "âœ… ECS service updated with new task definition: $NEW_TASK_DEF_ARN"

      - name: "Get Access Information"
        run: |
          # Get ECS service status
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster ${{ env.PROJECT_NAME }}-cluster \
            --services ${{ env.PROJECT_NAME }}-service \
            --query 'services[0].{running:runningCount,desired:desiredCount,status:status}' \
            --output json 2>/dev/null || echo '{}')

          # Get running instances in the ECS cluster
          INSTANCE_IDS=$(aws ec2 describe-instances \
            --filters "Name=tag:Project,Values=${{ env.PROJECT_NAME }}" \
                     "Name=tag:AmazonECSManaged,Values=true" \
                     "Name=instance-state-name,Values=running" \
            --query 'Reservations[].Instances[].InstanceId' \
            --output text 2>/dev/null || echo "")

          echo "## ðŸš€ DefectDojo Deployed Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Images built and pushed:**" >> $GITHUB_STEP_SUMMARY
          echo "- Django: \`$DJANGO_REPO:$IMAGE_TAG\`" >> $GITHUB_STEP_SUMMARY
          echo "- Nginx: \`$NGINX_REPO:$IMAGE_TAG\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**ECS Service Status:**" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`json" >> $GITHUB_STEP_SUMMARY
          echo "$SERVICE_STATUS" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -n "$INSTANCE_IDS" ]; then
            echo "**Access URLs:**" >> $GITHUB_STEP_SUMMARY
            for instance_id in $INSTANCE_IDS; do
              PUBLIC_IP=$(aws ec2 describe-instances \
                --instance-ids $instance_id \
                --query 'Reservations[0].Instances[0].PublicIpAddress' \
                --output text 2>/dev/null || echo "None")
              
              if [ "$PUBLIC_IP" != "None" ] && [ "$PUBLIC_IP" != "" ]; then
                echo "- http://$PUBLIC_IP/ (Instance: $instance_id)" >> $GITHUB_STEP_SUMMARY
              fi
            done
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Login Credentials:**" >> $GITHUB_STEP_SUMMARY
            echo "- Username: \`admin\`" >> $GITHUB_STEP_SUMMARY
            echo "- Password: \`DefectDojoMVP2024!\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Note:** No running instances found yet. ECS may still be launching containers." >> $GITHUB_STEP_SUMMARY
            echo "Check the ECS console for deployment progress." >> $GITHUB_STEP_SUMMARY
          fi
